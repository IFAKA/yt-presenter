// Fetches transcript via MAIN world (which uses ANDROID innertube client)
// The MAIN world runs on youtube.com origin, avoiding CORS and POT issues

window.YTPresenter = window.YTPresenter || {};

window.YTPresenter.fetchTranscript = async function(captionTracks, videoId, languageCode) {
  if ((!captionTracks || captionTracks.length === 0) && !videoId) {
    throw new Error('NO_CAPTIONS');
  }

  const lang = languageCode || 'en';

  // Find matching track — manual preferred over auto-generated
  // If captionTracks is null/empty, fall through and let the main-world innertube
  // fetch discover tracks (including auto-generated/ASR) from a fresh API call.
  const manual = captionTracks?.find(t => t.kind !== 'asr' && t.languageCode === lang);
  const autoLang = captionTracks?.find(t => t.languageCode === lang);
  const manualEn = captionTracks?.find(t => t.kind !== 'asr' && t.languageCode === 'en');
  const autoEn = captionTracks?.find(t => t.languageCode === 'en');
  const track = manual || autoLang || manualEn || autoEn;
  const isAutoGenerated = track ? track.kind === 'asr' : true;
  const resolvedLang = track ? track.languageCode : lang;

  const vid = videoId || new URLSearchParams(location.search).get('v');
  const requestId = Math.random().toString(36).slice(2);

  const segments = await new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      window.removeEventListener('message', handler);
      reject(new Error('Transcript fetch timed out'));
    }, 15000);

    function handler(event) {
      if (event.source !== window) return;
      if (event.data?.type !== 'YTPRES_TRANSCRIPT_RESULT') return;
      if (event.data.requestId !== requestId) return;

      window.removeEventListener('message', handler);
      clearTimeout(timeout);

      if (event.data.success) {
        resolve(event.data.segments);
      } else {
        reject(new Error(event.data.error || 'Transcript fetch failed'));
      }
    }

    window.addEventListener('message', handler);
    window.postMessage({
      type: 'YTPRES_FETCH_TRANSCRIPT',
      videoId: vid,
      languageCode: resolvedLang,
      requestId,
    }, window.location.origin);
  });

  if (!segments || segments.length === 0) {
    throw new Error('NO_CAPTIONS');
  }

  console.log('[YTPresenter] Got', segments.length, 'transcript segments (lang:', resolvedLang + ')');
  return { segments, isAutoGenerated, language: resolvedLang };
};

window.YTPresenter.segmentsToPlainText = function(segments) {
  return segments.map(s => s.text).join(' ');
};

// Map transcript segments to chapter time ranges
// Returns [{ title, text }] — plain text per chapter
window.YTPresenter.mapSegmentsToChapters = function(segments, chapters) {
  if (!chapters || chapters.length === 0) return null;

  // Sort chapters by startMs to be safe
  const sorted = [...chapters].sort((a, b) => a.startMs - b.startMs);

  return sorted.map((chapter, i) => {
    const startMs = chapter.startMs;
    const endMs = i < sorted.length - 1 ? sorted[i + 1].startMs : Infinity;

    const chapterSegments = segments.filter(
      seg => seg.startMs >= startMs && seg.startMs < endMs
    );

    return {
      title: chapter.title,
      text: chapterSegments.map(s => s.text).join(' '),
    };
  }).filter(ch => ch.text.trim());
};
